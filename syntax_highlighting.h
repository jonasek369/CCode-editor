#ifndef _H_SYNTAX_HIGHLIGHTING
#define _H_SYNTAX_HIGHLIGHTING

#include "defines.h"

#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

#define COLOR_KEYWORD 1
#define COLOR_STRING 2
#define COLOR_COMMENT 3
#define COLOR_NUMBER 4
#define COLOR_PREPROCESSOR 5
#define COLOR_TYPE 6
#define COLOR_OPERATOR 7
#define COLOR_DEFAULT 8

/*

	Generated by claude

*/


const char* c_keywords[] = {
    "auto", "break", "case", "char", "const", "continue", "default", "do",
    "double", "else", "enum", "extern", "float", "for", "goto", "if",
    "inline", "int", "long", "register", "restrict", "return", "short",
    "signed", "sizeof", "static", "struct", "switch", "typedef", "union",
    "unsigned", "void", "volatile", "while", "_Bool", "_Complex", "_Imaginary",
    NULL
};


const char* c_types[] = {
    "int8_t", "int16_t", "int32_t", "int64_t",
    "uint8_t", "uint16_t", "uint32_t", "uint64_t",
    "size_t", "ssize_t", "bool", "FILE", "NULL",
    NULL
};


#define COLOR_GRAY 8
#define COLOR_KEYWORD 1
#define COLOR_STRING 2
#define COLOR_COMMENT 3
#define COLOR_NUMBER 4
#define COLOR_PREPROCESSOR 5
#define COLOR_TYPE 6
#define COLOR_OPERATOR 7
#define COLOR_DEFAULT 9

void init_colors() {
    start_color();
    if (can_change_color()) {
        // Base colors
        init_color(COLOR_BLACK, 0, 0, 0);                     // background
        init_color(COLOR_WHITE, 880, 880, 880);               // var(white3)
        init_color(COLOR_RED, 1000, 500, 500);                // var(red)
        init_color(COLOR_GREEN, 450, 1000, 450);              // var(green)
        init_color(COLOR_BLUE, 300, 300, 1000);               // var(blue)
        init_color(COLOR_MAGENTA, 800, 400, 800);             // var(pink)
        init_color(COLOR_GRAY, 400, 400, 400);                // var(blue6)
        init_color(COLOR_YELLOW, 1000, 650, 300);             // var(orange)
        init_color(COLOR_CYAN, 300, 700, 700);                // var(blue5)
    }

    // Syntax color pairs (foreground, background)
    init_pair(COLOR_KEYWORD, COLOR_MAGENTA, COLOR_BLACK);      // keywords = pink
    init_pair(COLOR_STRING, COLOR_GREEN, COLOR_BLACK);         // strings = green
    init_pair(COLOR_COMMENT, COLOR_GRAY, COLOR_BLACK);         // comments = blue6/gray
    init_pair(COLOR_NUMBER, COLOR_YELLOW, COLOR_BLACK);        // numbers = orange
    init_pair(COLOR_PREPROCESSOR, COLOR_RED, COLOR_BLACK);     // constants/language variables
    init_pair(COLOR_TYPE, COLOR_CYAN, COLOR_BLACK);            // types/library class
    init_pair(COLOR_OPERATOR, COLOR_WHITE, COLOR_BLACK);       // operators/punctuation
    init_pair(COLOR_DEFAULT, COLOR_WHITE, COLOR_BLACK);        // default text
}


bool is_keyword(const char* word) {
    for (int i = 0; c_keywords[i] != NULL; i++) {
        if (strcmp(word, c_keywords[i]) == 0) {
            return true;
        }
    }
    return false;
}

bool is_type(const char* word) {
    for (int i = 0; c_types[i] != NULL; i++) {
        if (strcmp(word, c_types[i]) == 0) {
            return true;
        }
    }
    return false;
}


bool is_operator(char c) {
    return strchr("+-*/%=<>!&|^~?:", c) != NULL;
}


bool is_delimiter(char c) {
    return strchr(" \t(){}[].,;", c) != NULL || is_operator(c);
}

void apply_c_syntax_highlighting(char** visible_buffer, int32_t content_height) {
    static bool in_multiline_comment = false;
    

    for (int row = 0; row < content_height; row++) {
        if (visible_buffer[row] == NULL) continue;
        
        char* line = visible_buffer[row];
        int col = 0;
        int len = strlen(line);
        
        move(row+1, 0);
        clrtoeol();  // Clear only this line to end, not whole screen
        
        while (col < len) {
            // Handle multi-line comments continuation
            if (in_multiline_comment) {
                attron(COLOR_PAIR(COLOR_COMMENT));
                while (col < len - 1) {
                    if (line[col] == '*' && line[col + 1] == '/') {
                        addch(line[col++]);
                        addch(line[col++]);
                        in_multiline_comment = false;
                        break;
                    }
                    addch(line[col++]);
                }
                if (in_multiline_comment && col < len) {
                    addch(line[col++]);
                }
                attroff(COLOR_PAIR(COLOR_COMMENT));
                continue;
            }
            
            // Preprocessor directives
            if (col == 0 && line[col] == '#') {
                attron(COLOR_PAIR(COLOR_PREPROCESSOR));
                while (col < len && line[col] != '\n') {
                    addch(line[col++]);
                }
                attroff(COLOR_PAIR(COLOR_PREPROCESSOR));
                continue;
            }
            
            // Single-line comments
            if (col < len - 1 && line[col] == '/' && line[col + 1] == '/') {
                attron(COLOR_PAIR(COLOR_COMMENT));
                while (col < len) {
                    addch(line[col++]);
                }
                attroff(COLOR_PAIR(COLOR_COMMENT));
                continue;
            }
            
            // Multi-line comments
            if (col < len - 1 && line[col] == '/' && line[col + 1] == '*') {
                attron(COLOR_PAIR(COLOR_COMMENT));
                addch(line[col++]);
                addch(line[col++]);
                while (col < len - 1) {
                    if (line[col] == '*' && line[col + 1] == '/') {
                        addch(line[col++]);
                        addch(line[col++]);
                        break;
                    }
                    addch(line[col++]);
                }
                if (col < len && !(col > 1 && line[col-2] == '*' && line[col-1] == '/')) {
                    if (col == len - 1) {
                        addch(line[col++]);
                    }
                    in_multiline_comment = true;
                }
                attroff(COLOR_PAIR(COLOR_COMMENT));
                continue;
            }
            
            // String literals
            if (line[col] == '"') {
                attron(COLOR_PAIR(COLOR_STRING));
                addch(line[col++]);
                while (col < len && line[col] != '"') {
                    if (line[col] == '\\' && col + 1 < len) {
                        addch(line[col++]);
                        if (col < len) addch(line[col++]);
                    } else {
                        addch(line[col++]);
                    }
                }
                if (col < len) addch(line[col++]);
                attroff(COLOR_PAIR(COLOR_STRING));
                continue;
            }
            
            // Character literals
            if (line[col] == '\'') {
                attron(COLOR_PAIR(COLOR_STRING));
                addch(line[col++]);
                while (col < len && line[col] != '\'') {
                    if (line[col] == '\\' && col + 1 < len) {
                        addch(line[col++]);
                        if (col < len) addch(line[col++]);
                    } else {
                        addch(line[col++]);
                    }
                }
                if (col < len) addch(line[col++]);
                attroff(COLOR_PAIR(COLOR_STRING));
                continue;
            }
            
            // Numbers
            if (isdigit(line[col]) || 
                (line[col] == '.' && col + 1 < len && isdigit(line[col + 1]))) {
                attron(COLOR_PAIR(COLOR_NUMBER));
                if (line[col] == '0' && col + 1 < len && 
                    (line[col + 1] == 'x' || line[col + 1] == 'X')) {
                    // Hexadecimal
                    addch(line[col++]);
                    addch(line[col++]);
                    while (col < len && isxdigit(line[col])) {
                        addch(line[col++]);
                    }
                } else {
                    // Decimal or float
                    while (col < len && (isdigit(line[col]) || line[col] == '.' || 
                           line[col] == 'e' || line[col] == 'E' || 
                           line[col] == 'f' || line[col] == 'F' ||
                           line[col] == 'l' || line[col] == 'L' ||
                           line[col] == 'u' || line[col] == 'U')) {
                        addch(line[col++]);
                    }
                }
                attroff(COLOR_PAIR(COLOR_NUMBER));
                continue;
            }
            
            // Identifiers (keywords, types, or regular identifiers)
            if (isalpha(line[col]) || line[col] == '_') {
                char word[256];
                int word_len = 0;
                int start_col = col;
                
                while (col < len && (isalnum(line[col]) || line[col] == '_')) {
                    if (word_len < 255) {
                        word[word_len++] = line[col];
                    }
                    col++;
                }
                word[word_len] = '\0';
                
                // Determine color based on word type
                if (is_keyword(word)) {
                    attron(COLOR_PAIR(COLOR_KEYWORD));
                } else if (is_type(word)) {
                    attron(COLOR_PAIR(COLOR_TYPE));
                } else {
                    attron(COLOR_PAIR(COLOR_DEFAULT));
                }
                
                // Print the word
                for (int i = start_col; i < col; i++) {
                    addch(line[i]);
                }
                
                attroff(COLOR_PAIR(COLOR_KEYWORD));
                attroff(COLOR_PAIR(COLOR_TYPE));
                attroff(COLOR_PAIR(COLOR_DEFAULT));
                continue;
            }
            
            // Operators
            if (is_operator(line[col])) {
                attron(COLOR_PAIR(COLOR_OPERATOR));
                addch(line[col++]);
                // Handle multi-character operators
                if (col < len && is_operator(line[col]) && 
                    ((line[col-1] == '=' && line[col] == '=') ||
                     (line[col-1] == '!' && line[col] == '=') ||
                     (line[col-1] == '<' && line[col] == '=') ||
                     (line[col-1] == '>' && line[col] == '=') ||
                     (line[col-1] == '&' && line[col] == '&') ||
                     (line[col-1] == '|' && line[col] == '|') ||
                     (line[col-1] == '+' && line[col] == '+') ||
                     (line[col-1] == '-' && line[col] == '-') ||
                     (line[col-1] == '<' && line[col] == '<') ||
                     (line[col-1] == '>' && line[col] == '>') ||
                     (line[col-1] == '-' && line[col] == '>'))) {
                    addch(line[col++]);
                }
                attroff(COLOR_PAIR(COLOR_OPERATOR));
                continue;
            }
            
            // Default characters
            attron(COLOR_PAIR(COLOR_DEFAULT));
            addch(line[col++]);
            attroff(COLOR_PAIR(COLOR_DEFAULT));
        }
    }
}

void apply_c_syntax_highlighting_line(char* line, int row, bool* in_multiline_comment) {
    if (line == NULL) return;
    
    int col = 0;
    int len = strlen(line);
    
    move(row+1, 0);
    clrtoeol();
    
    while (col < len) {
        // Handle multi-line comments continuation
        if (*in_multiline_comment) {
            attron(COLOR_PAIR(COLOR_COMMENT));
            while (col < len - 1) {
                if (line[col] == '*' && line[col + 1] == '/') {
                    addch(line[col++]);
                    addch(line[col++]);
                    *in_multiline_comment = false;
                    break;
                }
                addch(line[col++]);
            }
            if (*in_multiline_comment && col < len) {
                addch(line[col++]);
            }
            attroff(COLOR_PAIR(COLOR_COMMENT));
            continue;
        }
        

        if (col == 0 && line[col] == '#') {
            attron(COLOR_PAIR(COLOR_PREPROCESSOR));
            while (col < len && line[col] != '\n') {
                addch(line[col++]);
            }
            attroff(COLOR_PAIR(COLOR_PREPROCESSOR));
            continue;
        }
        

        if (col < len - 1 && line[col] == '/' && line[col + 1] == '/') {
            attron(COLOR_PAIR(COLOR_COMMENT));
            while (col < len) {
                addch(line[col++]);
            }
            attroff(COLOR_PAIR(COLOR_COMMENT));
            continue;
        }
        

        if (col < len - 1 && line[col] == '/' && line[col + 1] == '*') {
            attron(COLOR_PAIR(COLOR_COMMENT));
            addch(line[col++]);
            addch(line[col++]);
            while (col < len - 1) {
                if (line[col] == '*' && line[col + 1] == '/') {
                    addch(line[col++]);
                    addch(line[col++]);
                    break;
                }
                addch(line[col++]);
            }
            if (col < len && !(col > 1 && line[col-2] == '*' && line[col-1] == '/')) {
                if (col == len - 1) {
                    addch(line[col++]);
                }
                *in_multiline_comment = true;
            }
            attroff(COLOR_PAIR(COLOR_COMMENT));
            continue;
        }
        

        if (line[col] == '"') {
            attron(COLOR_PAIR(COLOR_STRING));
            addch(line[col++]);
            while (col < len && line[col] != '"') {
                if (line[col] == '\\' && col + 1 < len) {
                    addch(line[col++]);
                    if (col < len) addch(line[col++]);
                } else {
                    addch(line[col++]);
                }
            }
            if (col < len) addch(line[col++]);
            attroff(COLOR_PAIR(COLOR_STRING));
            continue;
        }
        

        if (line[col] == '\'') {
            attron(COLOR_PAIR(COLOR_STRING));
            addch(line[col++]);
            while (col < len && line[col] != '\'') {
                if (line[col] == '\\' && col + 1 < len) {
                    addch(line[col++]);
                    if (col < len) addch(line[col++]);
                } else {
                    addch(line[col++]);
                }
            }
            if (col < len) addch(line[col++]);
            attroff(COLOR_PAIR(COLOR_STRING));
            continue;
        }
        
        // Numbers
        if (isdigit(line[col]) || 
            (line[col] == '.' && col + 1 < len && isdigit(line[col + 1]))) {
            attron(COLOR_PAIR(COLOR_NUMBER));
            if (line[col] == '0' && col + 1 < len && 
                (line[col + 1] == 'x' || line[col + 1] == 'X')) {
                // Hexadecimal
                addch(line[col++]);
                addch(line[col++]);
                while (col < len && isxdigit(line[col])) {
                    addch(line[col++]);
                }
            } else {
                // Decimal or float
                while (col < len && (isdigit(line[col]) || line[col] == '.' || 
                       line[col] == 'e' || line[col] == 'E' || 
                       line[col] == 'f' || line[col] == 'F' ||
                       line[col] == 'l' || line[col] == 'L' ||
                       line[col] == 'u' || line[col] == 'U')) {
                    addch(line[col++]);
                }
            }
            attroff(COLOR_PAIR(COLOR_NUMBER));
            continue;
        }
        
        // Identifiers (keywords, types, or regular identifiers)
        if (isalpha(line[col]) || line[col] == '_') {
            char word[256];
            int word_len = 0;
            int start_col = col;
            
            while (col < len && (isalnum(line[col]) || line[col] == '_')) {
                if (word_len < 255) {
                    word[word_len++] = line[col];
                }
                col++;
            }
            word[word_len] = '\0';
            
            // Determine color based on word type
            if (is_keyword(word)) {
                attron(COLOR_PAIR(COLOR_KEYWORD));
            } else if (is_type(word)) {
                attron(COLOR_PAIR(COLOR_TYPE));
            } else {
                attron(COLOR_PAIR(COLOR_DEFAULT));
            }
            
            // Print the word
            for (int i = start_col; i < col; i++) {
                addch(line[i]);
            }
            
            attroff(COLOR_PAIR(COLOR_KEYWORD));
            attroff(COLOR_PAIR(COLOR_TYPE));
            attroff(COLOR_PAIR(COLOR_DEFAULT));
            continue;
        }
        
        // Operators
        if (is_operator(line[col])) {
            attron(COLOR_PAIR(COLOR_OPERATOR));
            addch(line[col++]);
            // Handle multi-character operators
            if (col < len && is_operator(line[col]) && 
                ((line[col-1] == '=' && line[col] == '=') ||
                 (line[col-1] == '!' && line[col] == '=') ||
                 (line[col-1] == '<' && line[col] == '=') ||
                 (line[col-1] == '>' && line[col] == '=') ||
                 (line[col-1] == '&' && line[col] == '&') ||
                 (line[col-1] == '|' && line[col] == '|') ||
                 (line[col-1] == '+' && line[col] == '+') ||
                 (line[col-1] == '-' && line[col] == '-') ||
                 (line[col-1] == '<' && line[col] == '<') ||
                 (line[col-1] == '>' && line[col] == '>') ||
                 (line[col-1] == '-' && line[col] == '>'))) {
                addch(line[col++]);
            }
            attroff(COLOR_PAIR(COLOR_OPERATOR));
            continue;
        }
        
        // Default characters
        attron(COLOR_PAIR(COLOR_DEFAULT));
        addch(line[col++]);
        attroff(COLOR_PAIR(COLOR_DEFAULT));
    }
}


#endif